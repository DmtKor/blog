Блог

* Структура проекта *
 
 main.go
 src -- managedb -- managedb.go (разбить пакет на несколько файлов)
      \- handlers -- handlers.go (разбить пакет на несколько файлов)
       \- middleware -- middleware.go (скорее всего, хватит 1 файла)
        \- commander -- ? (CLI команды, управление жизненным циклом, т.е. инициализация и завершение)


* Модель данных: *

Записи хранятся в БД.
Доступ к данным через структуру с методами.
Весь функционал в пакете managedb.

Структуры Go:

Post {
    Id uint64          - номер
    Title string       - заголовок
    Description string - описание
    Content string     - содержимое
    PostDate time      - время публикации
    Tags []string      - теги
}
Comment {
    Id uint64      - id комментария
    PostId uint32  - id поста
    Author string  - Автор
    Content string - Текст
    CommDate time  - Время публикации
    Email string   - Почта
}

Таблицы PostgreSQL:

см. файл. 


* API *

GET /, /about - статическая страница со ссылками
GET /browse?[page=]&[pagesize=] - получить страницу page размера pagesize постов (по умолч. 1 и 10 соотв-но)
GET /doc?id= - получить пост по ID, теги и комментарии (без id - ошибка)
GET /newdoc - форма создания нового документа
POST /newdoc - API создания поста, возвращает на страницу нового поста
DELETE /article?id=.. - API удаления поста по ID, возвращает на /about
POST /comment?postid=.. - отправка комментария к посту с ID. возвращает ошибку или на страницу поста
DELETE /comment?commid=.. - удаление комментария к посту по ID комментария

Позже нужна авторизация

Все возвращается в HTML (если не будет фронтенда)


* Маршрутизация *

Через chi. Хендлеры в отдельном пакете handlers. Создаётся структура server, которая хранит в себе структуру БД
и роутер для прослушивания.
Если будет возможность сделать фронтенд, отправку статических файлов и динамического контента можно разделить.


* Middleware *

Логирование всех запросов через отправку в commander. 
Проверка, не пора завершается ли работа сервера.


* commander *

Есть структура commander. В ней канал с ошибками, канал с критическими ошибками (завершение), канал с информацией и 
канал ввода из CLI, также server. 
Запускается горутина, которая прослушивает все эти каналы через select и совершает действия, адекватные ситуации.
Отдельная горутина прослушивает пользовательский ввод, проводит минимальную обработку и отправляет рез-т в commander.
Есть методы: initServer (инициализация сервера, маршрутов, БД...)
             shutdownServer (дождаться завершения обработчиков запросов, завершить рутину, ожидающую новых запросов,
                             вызвать метод закрытия БД...)
             log (...)
Чтобы прервать все процессы, делается следующее: горутина, прослушивающая соединения, продолжает работать. Однако в 
middleware, который, осуществляет проверку работы сервера, изменяется значение, из-за чего он перенаправляет все за-
просы в один хендлер, который никак не учитывается при проверке завершения всех целевых горутин, он возвращает ошибку.
Все остальные процессы добавляют значение в WaitGroup, определенный в commander и сигнализируют о своем завершении для
этого объекта. Также при завершении работы сервера должно быть закрыто подключение к БД (уже после прекращения 
стандартной обработки соединения). После этого программа завершается.
